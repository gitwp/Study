########################1、为什么要有非阻塞算法#################################################################################
JVM 实现阻塞的方式通常是挂起阻塞的线程，过一会儿再重新调度它。由此造成的上下文切换相对于锁保护的少数几条指令来说，会造成相当大的延迟。

########################2、非阻塞算法的实现方式#################################################################################
非阻塞算法属于并发算法，它们不通过锁定，而是通过低级的原子性的硬件原生形式 —— 例如比较和交换，达到线程安全的目的。
非阻塞算法通常叫作乐观算法，因为它们继续操作的假设是不会有干扰。如果发现干扰，就会回退并重试。

########################3、性能优势与劣势#################################################################################
①、优势
	非阻塞版本相对于基于锁的版本有几个性能优势。首先，它用硬件的原生形态代替 JVM 的锁定代码路径，从而在更细的粒度层次上（独立的内存位置）进行同步，
失败的线程也可以立即重试，而不会被挂起后重新调度。更细的粒度降低了争用的机会，不用重新调度就能重试的能力也降低了争用的成本。即使有少量失败的 CAS 操作，
这种方法仍然会比由于锁争用造成的重新调度快得多。

	在轻度到中度的争用情况下，非阻塞算法的性能会超越阻塞算法，因为 CAS 的多数时间都在第一次尝试时就成功，而发生争用时的开销也不涉及线程挂起和上下
文切换，只多了几个循环迭代。没有争用的 CAS 要比没有争用的锁便宜得多（这句话肯定是真的，因为没有争用的锁涉及 CAS 加上额外的处理），而争用的 CAS比争
用的锁获取涉及更短的延迟。

②、劣势
	在高度争用的情况下（即有多个线程不断争用一个内存位置的时候），基于锁的算法开始提供比非阻塞算法更好的吞吐率，因为当线程阻塞时，它就会停止争用，
耐心地等候轮到自己，从而避免了进一步争用。但是，这么高的争用程度并不常见，因为多数时候，线程会把线程本地的计算与争用共享数据的操作分开，从而给其他
线程使用共享数据的机会。（这么高的争用程度也表明需要重新检查算法，朝着更少共享数据的方向努力。）


########################4、实例：################################################################################################
	（计数器NonblockingCounter和堆栈ConcurrentStack）都是非常简单的非阻塞算法，一旦掌握了在循环中使用 CAS，就可以容易地模仿它们。
	
	对于更复杂的数据结构，非阻塞算法要比这些简单示例复杂得多，因为修改链表、树或哈希表可能涉及对多个指针的更新。CAS 支持对单一指针的原子
性条件更新，但是不支持两个以上的指针。所以，要构建一个非阻塞的链表LinkedQueue、树或哈希表，需要找到一种方式，可以用 CAS 更新多个指针，
同时不会让数据结构处于不一致的状态。