线程
1、定义
	线程是一个对象，它代表程序内部的一种执行路径。
	Thread类实现了Runnable接口，Thread类的直接子类ForkJoinWorkerThread。
	
2、基本用法
	①、新建线程：新建一个类继承Thread类；新建一个类实现Runnable接口。
	②、启动线程：调用线程的start()方法。
	③、线程状态转换
							←←←←← 阻塞状态 ←←←←	
							↓					↑
						阻塞解除			导致阻塞的事件
							↓					↑
		创建-->start()-->就绪状态--CUP调度-->运行状态------>终止
	④、线程控制的基本方法
		isAlive():判断线程是否还“活”（就绪、运行、阻塞）着，即线程是否还未终止
		getPriority()：获取线程的优先级
		setPriority()：设置线程的优先级，1~10,默认是5
		Thread.sleep()：当前线程休眠指定的毫秒数，休眠期间被打断(interrupt方法)会抛出异常
		jion():调用某线程的该方法，将当前线程与该线程合并，即等待该线程结束再继续执行当前线程
		yield()：让出CPU，当前线程进入就绪队列等待调度
		wait()：当前线程进入对象的wait pool
		notify()/notifyAll():唤醒对象的wait pool中的一个/所有等待线程
		Thread.currentThread():获取当前线程
		
3、线程栈
	jvm运行时刻内存的分配，其中有一个内存区域是jvm虚拟机栈，每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。
当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存变量的具体值load到线程本地内存中，
建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，在修改完之后的某一个时刻（线程退出之前），
自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。
		
4、创建线程
①、继承Thread类
	多个线程无法共享线程类的实例变量
②、实现Runnable接口
	多个线程可以共享线程类的实例属性
③、使用Callable和Future
	Callable接口提供一个call()方法作为线程执行体，可以有返回值，可以声明抛出异常。
	由于Callable接口不是Runnable接口的子接口、所以Callable对象不能作为Thread的target;那么如何让call()方法做为线程的执行体呢？
	Future接口代表call()方法的返回值，FutureTask类作为Future接口的实现类，实现了Future接口同时实现了Runnable接口，它可以作为Thread的target；
	如此包装以达到call()方法作为线程的执行体的目的。