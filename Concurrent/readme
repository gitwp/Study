1、线程安全
	编写线程安全的代码，本质上就是管理对状态(state)的访问，而且通常都是共享的、可变的状态。
	
2、同步容器
	Vector,Hashtable是线程安全的同步容器(代码内部每个方法利用对象锁以达到同步效果)，但是在并发环境下进行复合操作时，比如：迭代、隐藏迭代器、导航、put-if-absent、check-then-act、remove-if-equal、replace-if-equal等
操作时需要客户端额外加锁操作才能达到不抛异常ConcurrentModificationException、正确执行的结果，不幸的是：客户端加锁不仅提高了代码的复杂度，同时削弱了并发性。

3、并发容器(JAVA5.0提供)
	同步容器公国对容器的所有状态进行串行访问，从而实现了它们的线程安全，这样做的代价是削弱了并发性，当多个线程共同竞争容器级的锁时，吞吐量就会降低
	并发容器是为多线程并发访问而设计的。JAVA5.0添加了ConcurrentHashMap来替代同步的Collections.synchronizedMap(Map<K,V> m)实现；当多数操作为读取操作时，CopyOnWriteArrayList来替代List相应的同步实现，新的ConcurrentMap
接口加入了对常见的符合操作的支持，比如putIfAbsent(K key, V value)、remove(Object key, Object value)、replace(K key, V oldValue, V newValue)
	用并发容器替换同步容器，这种做法【以有很小风行带来了可扩展性显著提高】

4、阻塞和可中断的方法
	线程可能会因为几种原因被阻塞或暂停：等待I/O操作结束，等待获得一个锁，等待从Thread.sleep中唤醒，或者是等待另一个线程的计算结果。
	当一个线程阻塞时，它通常被挂起，并设置成线程阻塞的某个状态(BLOCKED,WAITING,TIMED_WAITING)
	一个阻塞的操作和一个普通的操作之间的差别仅仅在于，被阻塞的线程必须等待一个事件的发生才能继续进行，并且这个事件是超越它自己控制的，当外部事件发生后，线程被重置会RUNNABLE状态，重新获得调度机会
	中断是一种协作机制，一个线程不能强迫使其他线程停止正在做的事情，或者去做其他事情，仅仅是要求其他线程在大成某个方便停止的关键点时，停止正在做的事情。
	当你在代码中调用一个会抛出InterruptedException的方法时，你自己的方法也就成为了一个阻塞方法，要为响应中断做好准备（传递InterruptedExcepion或者恢复中断）
	
5、Synchronizer
	Synchronizer是一个对象，它根据本身的状态调节现场的控制流。阻塞队列可以半夜一个Synchronizer的角色；其他类型的Synchronizer包括信号量（semaphore）、关卡（barrier）、闭锁（latch）,也可自己创建。
	①、闭锁（latch）它可以延迟线程的进度知道线程到达终止状态。一个闭锁工作起来就像一道大门：直到闭锁到达终点状态之前，门一直是关闭的，没有线程能够通过，在终点状态到来的时候，门开了，允许所有线程
都通过。一旦闭锁到达了终点状态，它就不能再改变状态了，所以它会永远保持敞开状态。
	②、信号量（semaphore）用来控制能够同时访问某特定资源的活动的数量，或者同时执行某一给定操作的数量，可以用来实现资源池或者一个容器限定边界。
	③、关卡（barrier）类似于闭锁，它们都能够阻塞一组线程，知道某些事件发生。其中关卡与闭锁关键的不同在于，所有线程必须同时到达关卡点，才能继续处理。闭锁等待的是事件；关卡等待的是其他线程。当线程
到达关卡点时，调用await,await会被阻塞，知道所有线程都到达关卡点。如果所有线程都到达了关卡点，关卡就被成功地突破，这样所有线程都被释放，关卡会重置以备下一次使用。如果对await的调用超时，或者阻塞中的
线程中断，那么关卡就被认为是失败的，所有对await未完成的调用都通过BrokenBarrierException终止。如果成功的通过关卡，await为每一个线程返回一个唯一的到达索引号，可以用它来选举产生一个领导，在下一次迭代中
承担一些特殊的工作。CyclicBarrier也允许你向构造函数传递一个关卡行为(barrier action)，这是一个Runnable，当成功通过关卡的时候，会在一个子任务线程中执行，但是在阻塞线程被释放之前是不能执行的。